diff --git a/README.md b/README.md
index 765e349..0ee2493 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,3 @@
-# tree-sitter-sml
+# tree-sitter-troupe
 
-Standard ML (SML) grammar for [tree-sitter](https://tree-sitter.github.io/tree-sitter/)
+Troupe grammar for [tree-sitter](https://tree-sitter.github.io/tree-sitter/)
diff --git a/grammar.js b/grammar.js
index 8fe5eac..1495bec 100644
--- a/grammar.js
+++ b/grammar.js
@@ -212,7 +212,7 @@ function mkSeq(cls) {
 // ******************************************************** //
 
 module.exports = grammar({
-    name: 'sml',
+    name: 'troupe',
 
     extras: $ => [
         token(/\s+/),
diff --git a/package.json b/package.json
index aa61e9d..3a430ff 100644
--- a/package.json
+++ b/package.json
@@ -1,6 +1,6 @@
 {
-    "name": "tree-sitter-sml",
-    "description": "Standard ML (SML) grammar for tree-sitter",
+    "name": "tree-sitter-troupe",
+    "description": "Troupe grammar for tree-sitter",
     "version": "0.1.0",
     "author": "Matthew Fluet <Matthew.Fluet@gmail.com> (https://github.com/MatthewFluet)",
     "license": "MIT",
@@ -16,7 +16,7 @@
         "parse": "tree-sitter parse",
         "highlight": "tree-sitter highlight",
         "prebuild": "npm run test",
-        "build": "cp ${XDG_CACHE_HOME:-${HOME}/.cache}/tree-sitter/lib/sml.so ."
+        "build": "cp ${XDG_CACHE_HOME:-${HOME}/.cache}/tree-sitter/lib/troupe.so ."
     },
     "dependencies": {
         "nan": "^2.16.0"
@@ -28,10 +28,7 @@
       {
           "scope": "source.ml",
           "file-types": [
-              "sml",
-              "sig",
-              "fun",
-              "ML"
+              "trp"
           ]
       }
     ]
diff --git a/src/scanner.c b/src/scanner.c
index 20b9327..7a83a86 100644
--- a/src/scanner.c
+++ b/src/scanner.c
@@ -6,23 +6,23 @@ enum TokenType {
   LINE_COMMENT,
 };
 
-void * tree_sitter_sml_external_scanner_create() {
+void * tree_sitter_troupe_external_scanner_create() {
   return NULL;
 }
 
-void tree_sitter_sml_external_scanner_destroy(void *payload) {
+void tree_sitter_troupe_external_scanner_destroy(void *payload) {
   return;
 }
 
-unsigned tree_sitter_sml_external_scanner_serialize(void *payload, char *buffer) {
+unsigned tree_sitter_troupe_external_scanner_serialize(void *payload, char *buffer) {
   return 0;
 }
 
-void tree_sitter_sml_external_scanner_deserialize(void *payload, const char *buffer, unsigned length) {
+void tree_sitter_troupe_external_scanner_deserialize(void *payload, const char *buffer, unsigned length) {
   return;
 }
 
-bool tree_sitter_sml_external_scanner_finish_line_comment(TSLexer *lexer) {
+bool tree_sitter_troupe_external_scanner_finish_line_comment(TSLexer *lexer) {
   while (true) {
     if (lexer->eof(lexer)) return false;
     switch (lexer->lookahead) {
@@ -42,7 +42,7 @@ bool tree_sitter_sml_external_scanner_finish_line_comment(TSLexer *lexer) {
   }
 }
 
-bool tree_sitter_sml_external_scanner_finish_block_comment(TSLexer *lexer, bool line_comment) {
+bool tree_sitter_troupe_external_scanner_finish_block_comment(TSLexer *lexer, bool line_comment) {
   unsigned depth = 1;
   while (true) {
     if (lexer->eof(lexer)) return false;
@@ -55,7 +55,7 @@ bool tree_sitter_sml_external_scanner_finish_block_comment(TSLexer *lexer, bool
         if (lexer->eof(lexer)) return false;
         if (line_comment && lexer->lookahead == ')') {
           lexer->advance(lexer, false);
-          if (tree_sitter_sml_external_scanner_finish_line_comment(lexer)) {
+          if (tree_sitter_troupe_external_scanner_finish_line_comment(lexer)) {
             continue;
           } else {
             return false;
@@ -88,7 +88,7 @@ bool tree_sitter_sml_external_scanner_finish_block_comment(TSLexer *lexer, bool
   }
 }
 
-bool tree_sitter_sml_external_scanner_scan_comment(TSLexer *lexer, bool block_comment, bool line_comment) {
+bool tree_sitter_troupe_external_scanner_scan_comment(TSLexer *lexer, bool block_comment, bool line_comment) {
   while (!lexer->eof(lexer) && iswspace(lexer->lookahead)) {
     lexer->advance(lexer, true);
   }
@@ -101,14 +101,14 @@ bool tree_sitter_sml_external_scanner_scan_comment(TSLexer *lexer, bool block_co
       if (lexer->eof(lexer)) return false;
       if (line_comment && lexer->lookahead == ')') {
         lexer->advance(lexer, false);
-        if (tree_sitter_sml_external_scanner_finish_line_comment(lexer)) {
+        if (tree_sitter_troupe_external_scanner_finish_line_comment(lexer)) {
           lexer->result_symbol = LINE_COMMENT;
           return true;
         } else {
           return false;
         }
       } else if (block_comment) {
-        if (tree_sitter_sml_external_scanner_finish_block_comment(lexer, line_comment)) {
+        if (tree_sitter_troupe_external_scanner_finish_block_comment(lexer, line_comment)) {
           lexer->result_symbol = BLOCK_COMMENT;
           return true;
         } else {
@@ -125,9 +125,9 @@ bool tree_sitter_sml_external_scanner_scan_comment(TSLexer *lexer, bool block_co
   }
 }
 
-bool tree_sitter_sml_external_scanner_scan(void *payload, TSLexer *lexer, const bool *valid_symbols) {
+bool tree_sitter_troupe_external_scanner_scan(void *payload, TSLexer *lexer, const bool *valid_symbols) {
   if (valid_symbols[BLOCK_COMMENT] || valid_symbols[LINE_COMMENT]) {
-    return tree_sitter_sml_external_scanner_scan_comment(lexer, valid_symbols[BLOCK_COMMENT], valid_symbols[LINE_COMMENT]);
+    return tree_sitter_troupe_external_scanner_scan_comment(lexer, valid_symbols[BLOCK_COMMENT], valid_symbols[LINE_COMMENT]);
   } else {
     return false;
   }
